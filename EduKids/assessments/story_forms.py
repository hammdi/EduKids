"""
Story Management Forms with Validation - EduKids
"""
from django import forms
from django.core.exceptions import ValidationError
from .story_models import Story
import json


class StoryForm(forms.ModelForm):
    """
    Form for creating and editing stories with comprehensive validation
    """
    
    # Override fields for better widgets and validation
    title = forms.CharField(
        max_length=200,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Enter story title (e.g., "The Brave Little Robot")',
            'required': True
        }),
        help_text='Story title (3-200 characters)'
    )
    
    theme = forms.ChoiceField(
        choices=Story.THEME_CHOICES,
        widget=forms.Select(attrs={
            'class': 'form-control',
            'required': True
        }),
        help_text='Select the main theme of the story'
    )
    
    age_group = forms.ChoiceField(
        choices=Story.AGE_GROUP_CHOICES,
        widget=forms.Select(attrs={
            'class': 'form-control',
            'required': True
        }),
        help_text='Target age group for this story'
    )
    
    difficulty_level = forms.IntegerField(
        min_value=1,
        max_value=5,
        widget=forms.NumberInput(attrs={
            'class': 'form-control',
            'min': '1',
            'max': '5',
            'required': True
        }),
        help_text='Difficulty level from 1 (easy) to 5 (hard)'
    )
    
    reading_time_minutes = forms.IntegerField(
        min_value=1,
        max_value=30,
        widget=forms.NumberInput(attrs={
            'class': 'form-control',
            'min': '1',
            'max': '30',
            'required': True
        }),
        help_text='Estimated reading time in minutes (1-30)'
    )
    
    # JSON fields as text areas
    story_content = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': '10',
            'placeholder': 'Enter story paragraphs, one per line',
            'required': True
        }),
        help_text='Story paragraphs (one per line, minimum 2 paragraphs)'
    )
    
    characters = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': '3',
            'placeholder': 'Enter character names, one per line',
            'required': True
        }),
        help_text='Main character names (one per line, 1-5 characters)'
    )
    
    questions = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': '8',
            'placeholder': 'Format: Question? | Answer\nExample: What did the robot learn? | The robot learned about friendship',
            'required': True
        }),
        help_text='Questions and answers (Format: Question? | Answer, one per line, 3-5 questions)'
    )
    
    generated_by_ai = forms.BooleanField(
        required=False,
        widget=forms.CheckboxInput(attrs={
            'class': 'form-check-input'
        }),
        help_text='Check if this story was generated by AI'
    )
    
    class Meta:
        model = Story
        fields = [
            'title', 'theme', 'age_group', 'story_content', 
            'characters', 'questions', 'difficulty_level', 
            'reading_time_minutes', 'generated_by_ai'
        ]
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # If editing existing story, convert JSON to text
        if self.instance and self.instance.pk:
            if isinstance(self.instance.story_content, list):
                self.initial['story_content'] = '\n'.join(self.instance.story_content)
            
            if isinstance(self.instance.characters, list):
                self.initial['characters'] = '\n'.join(self.instance.characters)
            
            if isinstance(self.instance.questions, list):
                questions_text = []
                for q in self.instance.questions:
                    if isinstance(q, dict):
                        questions_text.append(f"{q.get('question', '')} | {q.get('answer', '')}")
                self.initial['questions'] = '\n'.join(questions_text)
    
    def clean_title(self):
        """Validate story title"""
        title = self.cleaned_data.get('title', '').strip()
        
        if not title:
            raise ValidationError('Title is required.')
        
        if len(title) < 3:
            raise ValidationError('Title must be at least 3 characters long.')
        
        if len(title) > 200:
            raise ValidationError('Title must not exceed 200 characters.')
        
        # Check for duplicate titles (excluding current instance)
        existing = Story.objects.filter(title__iexact=title)
        if self.instance and self.instance.pk:
            existing = existing.exclude(pk=self.instance.pk)
        
        if existing.exists():
            raise ValidationError('A story with this title already exists.')
        
        return title
    
    def clean_story_content(self):
        """Validate and convert story content to JSON list"""
        content = self.cleaned_data.get('story_content', '').strip()
        
        if not content:
            raise ValidationError('Story content is required.')
        
        # Split by newlines and filter empty lines
        paragraphs = [p.strip() for p in content.split('\n') if p.strip()]
        
        if len(paragraphs) < 2:
            raise ValidationError('Story must have at least 2 paragraphs.')
        
        if len(paragraphs) > 20:
            raise ValidationError('Story must not exceed 20 paragraphs.')
        
        # Validate each paragraph
        for i, paragraph in enumerate(paragraphs, 1):
            if len(paragraph) < 10:
                raise ValidationError(f'Paragraph {i} is too short (minimum 10 characters).')
            if len(paragraph) > 1000:
                raise ValidationError(f'Paragraph {i} is too long (maximum 1000 characters).')
        
        return paragraphs
    
    def clean_characters(self):
        """Validate and convert characters to JSON list"""
        characters_text = self.cleaned_data.get('characters', '').strip()
        
        if not characters_text:
            raise ValidationError('At least one character is required.')
        
        # Split by newlines and filter empty lines
        characters = [c.strip() for c in characters_text.split('\n') if c.strip()]
        
        if len(characters) < 1:
            raise ValidationError('At least one character is required.')
        
        if len(characters) > 5:
            raise ValidationError('Maximum 5 characters allowed.')
        
        # Validate each character name
        for i, character in enumerate(characters, 1):
            if len(character) < 2:
                raise ValidationError(f'Character {i} name is too short (minimum 2 characters).')
            if len(character) > 50:
                raise ValidationError(f'Character {i} name is too long (maximum 50 characters).')
        
        return characters
    
    def clean_questions(self):
        """Validate and convert questions to JSON list"""
        questions_text = self.cleaned_data.get('questions', '').strip()
        
        if not questions_text:
            raise ValidationError('Questions are required.')
        
        # Split by newlines and filter empty lines
        lines = [line.strip() for line in questions_text.split('\n') if line.strip()]
        
        if len(lines) < 3:
            raise ValidationError('At least 3 questions are required.')
        
        if len(lines) > 5:
            raise ValidationError('Maximum 5 questions allowed.')
        
        # Parse questions and answers
        questions = []
        for i, line in enumerate(lines, 1):
            if '|' not in line:
                raise ValidationError(
                    f'Line {i}: Invalid format. Use "Question? | Answer" format.'
                )
            
            parts = line.split('|', 1)
            if len(parts) != 2:
                raise ValidationError(
                    f'Line {i}: Invalid format. Use "Question? | Answer" format.'
                )
            
            question = parts[0].strip()
            answer = parts[1].strip()
            
            if not question:
                raise ValidationError(f'Line {i}: Question is empty.')
            
            if not answer:
                raise ValidationError(f'Line {i}: Answer is empty.')
            
            if len(question) < 5:
                raise ValidationError(f'Line {i}: Question is too short (minimum 5 characters).')
            
            if len(question) > 200:
                raise ValidationError(f'Line {i}: Question is too long (maximum 200 characters).')
            
            if len(answer) < 3:
                raise ValidationError(f'Line {i}: Answer is too short (minimum 3 characters).')
            
            if len(answer) > 500:
                raise ValidationError(f'Line {i}: Answer is too long (maximum 500 characters).')
            
            questions.append({
                'question': question,
                'answer': answer
            })
        
        return questions
    
    def clean_difficulty_level(self):
        """Validate difficulty level"""
        level = self.cleaned_data.get('difficulty_level')
        
        if level is None:
            raise ValidationError('Difficulty level is required.')
        
        if level < 1 or level > 5:
            raise ValidationError('Difficulty level must be between 1 and 5.')
        
        return level
    
    def clean_reading_time_minutes(self):
        """Validate reading time"""
        time = self.cleaned_data.get('reading_time_minutes')
        
        if time is None:
            raise ValidationError('Reading time is required.')
        
        if time < 1:
            raise ValidationError('Reading time must be at least 1 minute.')
        
        if time > 30:
            raise ValidationError('Reading time must not exceed 30 minutes.')
        
        return time
    
    def clean(self):
        """Additional cross-field validation"""
        cleaned_data = super().clean()
        
        # Validate age group vs difficulty level
        age_group = cleaned_data.get('age_group')
        difficulty = cleaned_data.get('difficulty_level')
        
        if age_group and difficulty:
            # Younger kids should have easier stories
            if age_group == '6-7' and difficulty > 3:
                raise ValidationError({
                    'difficulty_level': 'Difficulty level too high for age group 6-7. Maximum level 3 recommended.'
                })
            
            if age_group == '7-8' and difficulty > 4:
                raise ValidationError({
                    'difficulty_level': 'Difficulty level too high for age group 7-8. Maximum level 4 recommended.'
                })
        
        return cleaned_data


class StorySearchForm(forms.Form):
    """
    Form for searching and filtering stories
    """
    search = forms.CharField(
        required=False,
        widget=forms.TextInput(attrs={
            'class': 'form-control',
            'placeholder': 'Search by title...'
        })
    )
    
    theme = forms.ChoiceField(
        required=False,
        choices=[('', 'All Themes')] + list(Story.THEME_CHOICES),
        widget=forms.Select(attrs={
            'class': 'form-control'
        })
    )
    
    age_group = forms.ChoiceField(
        required=False,
        choices=[('', 'All Ages')] + list(Story.AGE_GROUP_CHOICES),
        widget=forms.Select(attrs={
            'class': 'form-control'
        })
    )
    
    difficulty = forms.ChoiceField(
        required=False,
        choices=[('', 'All Levels')] + [(str(i), f'Level {i}') for i in range(1, 6)],
        widget=forms.Select(attrs={
            'class': 'form-control'
        })
    )
